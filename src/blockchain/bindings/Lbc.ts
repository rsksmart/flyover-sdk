/* Autogenerated file. Do not edit manually. */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace LiquidityBridgeContractV2 {
  export type LiquidityProviderStruct = {
    id: PromiseOrValue<BigNumberish>;
    provider: PromiseOrValue<string>;
    name: PromiseOrValue<string>;
    apiBaseUrl: PromiseOrValue<string>;
    status: PromiseOrValue<boolean>;
    providerType: PromiseOrValue<string>;
  };

  export type LiquidityProviderStructOutput = [
    BigNumber,
    string,
    string,
    string,
    boolean,
    string
  ] & {
    id: BigNumber;
    provider: string;
    name: string;
    apiBaseUrl: string;
    status: boolean;
    providerType: string;
  };
}

export declare namespace QuotesV2 {
  export type PeginQuoteStruct = {
    fedBtcAddress: PromiseOrValue<BytesLike>;
    lbcAddress: PromiseOrValue<string>;
    liquidityProviderRskAddress: PromiseOrValue<string>;
    btcRefundAddress: PromiseOrValue<BytesLike>;
    rskRefundAddress: PromiseOrValue<string>;
    liquidityProviderBtcAddress: PromiseOrValue<BytesLike>;
    callFee: PromiseOrValue<BigNumberish>;
    penaltyFee: PromiseOrValue<BigNumberish>;
    contractAddress: PromiseOrValue<string>;
    data: PromiseOrValue<BytesLike>;
    gasLimit: PromiseOrValue<BigNumberish>;
    nonce: PromiseOrValue<BigNumberish>;
    value: PromiseOrValue<BigNumberish>;
    agreementTimestamp: PromiseOrValue<BigNumberish>;
    timeForDeposit: PromiseOrValue<BigNumberish>;
    callTime: PromiseOrValue<BigNumberish>;
    depositConfirmations: PromiseOrValue<BigNumberish>;
    callOnRegister: PromiseOrValue<boolean>;
    productFeeAmount: PromiseOrValue<BigNumberish>;
    gasFee: PromiseOrValue<BigNumberish>;
  };

  export type PeginQuoteStructOutput = [
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string,
    string,
    number,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    number,
    boolean,
    BigNumber,
    BigNumber
  ] & {
    fedBtcAddress: string;
    lbcAddress: string;
    liquidityProviderRskAddress: string;
    btcRefundAddress: string;
    rskRefundAddress: string;
    liquidityProviderBtcAddress: string;
    callFee: BigNumber;
    penaltyFee: BigNumber;
    contractAddress: string;
    data: string;
    gasLimit: number;
    nonce: BigNumber;
    value: BigNumber;
    agreementTimestamp: number;
    timeForDeposit: number;
    callTime: number;
    depositConfirmations: number;
    callOnRegister: boolean;
    productFeeAmount: BigNumber;
    gasFee: BigNumber;
  };

  export type PegOutQuoteStruct = {
    lbcAddress: PromiseOrValue<string>;
    lpRskAddress: PromiseOrValue<string>;
    btcRefundAddress: PromiseOrValue<BytesLike>;
    rskRefundAddress: PromiseOrValue<string>;
    lpBtcAddress: PromiseOrValue<BytesLike>;
    callFee: PromiseOrValue<BigNumberish>;
    penaltyFee: PromiseOrValue<BigNumberish>;
    nonce: PromiseOrValue<BigNumberish>;
    deposityAddress: PromiseOrValue<BytesLike>;
    value: PromiseOrValue<BigNumberish>;
    agreementTimestamp: PromiseOrValue<BigNumberish>;
    depositDateLimit: PromiseOrValue<BigNumberish>;
    depositConfirmations: PromiseOrValue<BigNumberish>;
    transferConfirmations: PromiseOrValue<BigNumberish>;
    transferTime: PromiseOrValue<BigNumberish>;
    expireDate: PromiseOrValue<BigNumberish>;
    expireBlock: PromiseOrValue<BigNumberish>;
    productFeeAmount: PromiseOrValue<BigNumberish>;
    gasFee: PromiseOrValue<BigNumberish>;
  };

  export type PegOutQuoteStructOutput = [
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    BigNumber,
    BigNumber
  ] & {
    lbcAddress: string;
    lpRskAddress: string;
    btcRefundAddress: string;
    rskRefundAddress: string;
    lpBtcAddress: string;
    callFee: BigNumber;
    penaltyFee: BigNumber;
    nonce: BigNumber;
    deposityAddress: string;
    value: BigNumber;
    agreementTimestamp: number;
    depositDateLimit: number;
    depositConfirmations: number;
    transferConfirmations: number;
    transferTime: number;
    expireDate: number;
    expireBlock: number;
    productFeeAmount: BigNumber;
    gasFee: BigNumber;
  };
}

export interface LbcInterface extends utils.Interface {
  functions: {
    "BRIDGE_GENERIC_ERROR()": FunctionFragment;
    "BRIDGE_REFUNDED_LP_ERROR_CODE()": FunctionFragment;
    "BRIDGE_REFUNDED_USER_ERROR_CODE()": FunctionFragment;
    "BRIDGE_UNPROCESSABLE_TX_ALREADY_PROCESSED_ERROR_CODE()": FunctionFragment;
    "BRIDGE_UNPROCESSABLE_TX_INVALID_SENDER_ERROR_CODE()": FunctionFragment;
    "BRIDGE_UNPROCESSABLE_TX_NOT_CONTRACT_ERROR_CODE()": FunctionFragment;
    "BRIDGE_UNPROCESSABLE_TX_UTXO_AMOUNT_SENT_BELOW_MINIMUM_ERROR()": FunctionFragment;
    "BRIDGE_UNPROCESSABLE_TX_VALIDATIONS_ERROR()": FunctionFragment;
    "BRIDGE_UNPROCESSABLE_TX_VALUE_ZERO_ERROR()": FunctionFragment;
    "CALL_DONE_CODE()": FunctionFragment;
    "MAX_CALL_GAS_COST()": FunctionFragment;
    "MAX_REFUND_GAS_LIMIT()": FunctionFragment;
    "PAY_TO_ADDRESS_OUTPUT()": FunctionFragment;
    "PROCESSED_QUOTE_CODE()": FunctionFragment;
    "QUOTE_HASH_OUTPUT()": FunctionFragment;
    "UNPROCESSED_QUOTE_CODE()": FunctionFragment;
    "bridge()": FunctionFragment;
    "daoFeeCollectorAddress()": FunctionFragment;
    "owner()": FunctionFragment;
    "productFeePercentage()": FunctionFragment;
    "providerId()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "setProviderStatus(uint256,bool)": FunctionFragment;
    "getProviderIds()": FunctionFragment;
    "getBridgeAddress()": FunctionFragment;
    "getMinCollateral()": FunctionFragment;
    "getMinPegIn()": FunctionFragment;
    "getRewardPercentage()": FunctionFragment;
    "getResignDelayBlocks()": FunctionFragment;
    "getDustThreshold()": FunctionFragment;
    "isPegOutQuoteCompleted(bytes32)": FunctionFragment;
    "isOperational(address)": FunctionFragment;
    "isOperationalForPegout(address)": FunctionFragment;
    "register(string,string,bool,string)": FunctionFragment;
    "getProviders()": FunctionFragment;
    "getProvider(address)": FunctionFragment;
    "addCollateral()": FunctionFragment;
    "addPegoutCollateral()": FunctionFragment;
    "deposit()": FunctionFragment;
    "withdraw(uint256)": FunctionFragment;
    "withdrawCollateral()": FunctionFragment;
    "resign()": FunctionFragment;
    "getCollateral(address)": FunctionFragment;
    "getPegoutCollateral(address)": FunctionFragment;
    "getBalance(address)": FunctionFragment;
    "callForUser((bytes20,address,address,bytes,address,bytes,uint256,uint256,address,bytes,uint32,int64,uint256,uint32,uint32,uint32,uint16,bool,uint256,uint256))": FunctionFragment;
    "registerPegIn((bytes20,address,address,bytes,address,bytes,uint256,uint256,address,bytes,uint32,int64,uint256,uint32,uint32,uint32,uint16,bool,uint256,uint256),bytes,bytes,bytes,uint256)": FunctionFragment;
    "depositPegout((address,address,bytes,address,bytes,uint256,uint256,int64,bytes,uint256,uint32,uint32,uint16,uint16,uint32,uint32,uint32,uint256,uint256),bytes)": FunctionFragment;
    "refundUserPegOut(bytes32)": FunctionFragment;
    "refundPegOut(bytes32,bytes,bytes32,uint256,bytes32[])": FunctionFragment;
    "validatePeginDepositAddress((bytes20,address,address,bytes,address,bytes,uint256,uint256,address,bytes,uint32,int64,uint256,uint32,uint32,uint32,uint16,bool,uint256,uint256),bytes)": FunctionFragment;
    "hashQuote((bytes20,address,address,bytes,address,bytes,uint256,uint256,address,bytes,uint32,int64,uint256,uint32,uint32,uint32,uint16,bool,uint256,uint256))": FunctionFragment;
    "hashPegoutQuote((address,address,bytes,address,bytes,uint256,uint256,int64,bytes,uint256,uint32,uint32,uint16,uint16,uint32,uint32,uint32,uint256,uint256))": FunctionFragment;
    "updateProvider(string,string)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "BRIDGE_GENERIC_ERROR"
      | "BRIDGE_REFUNDED_LP_ERROR_CODE"
      | "BRIDGE_REFUNDED_USER_ERROR_CODE"
      | "BRIDGE_UNPROCESSABLE_TX_ALREADY_PROCESSED_ERROR_CODE"
      | "BRIDGE_UNPROCESSABLE_TX_INVALID_SENDER_ERROR_CODE"
      | "BRIDGE_UNPROCESSABLE_TX_NOT_CONTRACT_ERROR_CODE"
      | "BRIDGE_UNPROCESSABLE_TX_UTXO_AMOUNT_SENT_BELOW_MINIMUM_ERROR"
      | "BRIDGE_UNPROCESSABLE_TX_VALIDATIONS_ERROR"
      | "BRIDGE_UNPROCESSABLE_TX_VALUE_ZERO_ERROR"
      | "CALL_DONE_CODE"
      | "MAX_CALL_GAS_COST"
      | "MAX_REFUND_GAS_LIMIT"
      | "PAY_TO_ADDRESS_OUTPUT"
      | "PROCESSED_QUOTE_CODE"
      | "QUOTE_HASH_OUTPUT"
      | "UNPROCESSED_QUOTE_CODE"
      | "bridge"
      | "daoFeeCollectorAddress"
      | "owner"
      | "productFeePercentage"
      | "providerId"
      | "renounceOwnership"
      | "transferOwnership"
      | "setProviderStatus"
      | "getProviderIds"
      | "getBridgeAddress"
      | "getMinCollateral"
      | "getMinPegIn"
      | "getRewardPercentage"
      | "getResignDelayBlocks"
      | "getDustThreshold"
      | "isPegOutQuoteCompleted"
      | "isOperational"
      | "isOperationalForPegout"
      | "register"
      | "getProviders"
      | "getProvider"
      | "addCollateral"
      | "addPegoutCollateral"
      | "deposit"
      | "withdraw"
      | "withdrawCollateral"
      | "resign"
      | "getCollateral"
      | "getPegoutCollateral"
      | "getBalance"
      | "callForUser"
      | "registerPegIn"
      | "depositPegout"
      | "refundUserPegOut"
      | "refundPegOut"
      | "validatePeginDepositAddress"
      | "hashQuote"
      | "hashPegoutQuote"
      | "updateProvider"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "BRIDGE_GENERIC_ERROR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BRIDGE_REFUNDED_LP_ERROR_CODE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BRIDGE_REFUNDED_USER_ERROR_CODE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_ALREADY_PROCESSED_ERROR_CODE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_INVALID_SENDER_ERROR_CODE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_NOT_CONTRACT_ERROR_CODE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_UTXO_AMOUNT_SENT_BELOW_MINIMUM_ERROR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_VALIDATIONS_ERROR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_VALUE_ZERO_ERROR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "CALL_DONE_CODE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_CALL_GAS_COST",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_REFUND_GAS_LIMIT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PAY_TO_ADDRESS_OUTPUT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PROCESSED_QUOTE_CODE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "QUOTE_HASH_OUTPUT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "UNPROCESSED_QUOTE_CODE",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "bridge", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "daoFeeCollectorAddress",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "productFeePercentage",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "providerId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setProviderStatus",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProviderIds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBridgeAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMinCollateral",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMinPegIn",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRewardPercentage",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getResignDelayBlocks",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDustThreshold",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isPegOutQuoteCompleted",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isOperational",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isOperationalForPegout",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "register",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getProviders",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getProvider",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addCollateral",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addPegoutCollateral",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "deposit", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawCollateral",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "resign", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getCollateral",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPegoutCollateral",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBalance",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "callForUser",
    values: [QuotesV2.PeginQuoteStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "registerPegIn",
    values: [
      QuotesV2.PeginQuoteStruct,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositPegout",
    values: [QuotesV2.PegOutQuoteStruct, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "refundUserPegOut",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "refundPegOut",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "validatePeginDepositAddress",
    values: [QuotesV2.PeginQuoteStruct, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "hashQuote",
    values: [QuotesV2.PeginQuoteStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "hashPegoutQuote",
    values: [QuotesV2.PegOutQuoteStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateProvider",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "BRIDGE_GENERIC_ERROR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BRIDGE_REFUNDED_LP_ERROR_CODE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BRIDGE_REFUNDED_USER_ERROR_CODE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_ALREADY_PROCESSED_ERROR_CODE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_INVALID_SENDER_ERROR_CODE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_NOT_CONTRACT_ERROR_CODE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_UTXO_AMOUNT_SENT_BELOW_MINIMUM_ERROR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_VALIDATIONS_ERROR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BRIDGE_UNPROCESSABLE_TX_VALUE_ZERO_ERROR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "CALL_DONE_CODE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_CALL_GAS_COST",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_REFUND_GAS_LIMIT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PAY_TO_ADDRESS_OUTPUT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PROCESSED_QUOTE_CODE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "QUOTE_HASH_OUTPUT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "UNPROCESSED_QUOTE_CODE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "bridge", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "daoFeeCollectorAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "productFeePercentage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "providerId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setProviderStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProviderIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBridgeAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMinCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMinPegIn",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRewardPercentage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getResignDelayBlocks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDustThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isPegOutQuoteCompleted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOperational",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOperationalForPegout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "register", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getProviders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addPegoutCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resign", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPegoutCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getBalance", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "callForUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerPegIn",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositPegout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "refundUserPegOut",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "refundPegOut",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validatePeginDepositAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hashQuote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "hashPegoutQuote",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateProvider",
    data: BytesLike
  ): Result;

  events: {
    "BalanceDecrease(address,uint256)": EventFragment;
    "BalanceIncrease(address,uint256)": EventFragment;
    "BridgeCapExceeded(bytes32,int256)": EventFragment;
    "CallForUser(address,address,uint256,uint256,bytes,bool,bytes32)": EventFragment;
    "CollateralIncrease(address,uint256)": EventFragment;
    "DaoFeeSent(bytes32,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "PegInRegistered(bytes32,int256)": EventFragment;
    "PegOutDeposit(bytes32,address,uint256,uint256)": EventFragment;
    "PegOutRefunded(bytes32)": EventFragment;
    "PegOutUserRefunded(bytes32,uint256,address)": EventFragment;
    "PegoutCollateralIncrease(address,uint256)": EventFragment;
    "Penalized(address,uint256,bytes32)": EventFragment;
    "ProviderUpdate(address,string,string)": EventFragment;
    "Refund(address,uint256,bool,bytes32)": EventFragment;
    "Register(uint256,address,uint256)": EventFragment;
    "Resigned(address)": EventFragment;
    "WithdrawCollateral(address,uint256)": EventFragment;
    "Withdrawal(address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "BalanceDecrease"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BalanceIncrease"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BridgeCapExceeded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CallForUser"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CollateralIncrease"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DaoFeeSent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PegInRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PegOutDeposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PegOutRefunded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PegOutUserRefunded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PegoutCollateralIncrease"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Penalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProviderUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Refund"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Register"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Resigned"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawCollateral"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawal"): EventFragment;
}

export interface BalanceDecreaseEventObject {
  dest: string;
  amount: BigNumber;
}
export type BalanceDecreaseEvent = TypedEvent<
  [string, BigNumber],
  BalanceDecreaseEventObject
>;

export type BalanceDecreaseEventFilter = TypedEventFilter<BalanceDecreaseEvent>;

export interface BalanceIncreaseEventObject {
  dest: string;
  amount: BigNumber;
}
export type BalanceIncreaseEvent = TypedEvent<
  [string, BigNumber],
  BalanceIncreaseEventObject
>;

export type BalanceIncreaseEventFilter = TypedEventFilter<BalanceIncreaseEvent>;

export interface BridgeCapExceededEventObject {
  quoteHash: string;
  errorCode: BigNumber;
}
export type BridgeCapExceededEvent = TypedEvent<
  [string, BigNumber],
  BridgeCapExceededEventObject
>;

export type BridgeCapExceededEventFilter =
  TypedEventFilter<BridgeCapExceededEvent>;

export interface CallForUserEventObject {
  from: string;
  dest: string;
  gasLimit: BigNumber;
  value: BigNumber;
  data: string;
  success: boolean;
  quoteHash: string;
}
export type CallForUserEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, string, boolean, string],
  CallForUserEventObject
>;

export type CallForUserEventFilter = TypedEventFilter<CallForUserEvent>;

export interface CollateralIncreaseEventObject {
  from: string;
  amount: BigNumber;
}
export type CollateralIncreaseEvent = TypedEvent<
  [string, BigNumber],
  CollateralIncreaseEventObject
>;

export type CollateralIncreaseEventFilter =
  TypedEventFilter<CollateralIncreaseEvent>;

export interface DaoFeeSentEventObject {
  quoteHash: string;
  amount: BigNumber;
}
export type DaoFeeSentEvent = TypedEvent<
  [string, BigNumber],
  DaoFeeSentEventObject
>;

export type DaoFeeSentEventFilter = TypedEventFilter<DaoFeeSentEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PegInRegisteredEventObject {
  quoteHash: string;
  transferredAmount: BigNumber;
}
export type PegInRegisteredEvent = TypedEvent<
  [string, BigNumber],
  PegInRegisteredEventObject
>;

export type PegInRegisteredEventFilter = TypedEventFilter<PegInRegisteredEvent>;

export interface PegOutDepositEventObject {
  quoteHash: string;
  sender: string;
  amount: BigNumber;
  timestamp: BigNumber;
}
export type PegOutDepositEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  PegOutDepositEventObject
>;

export type PegOutDepositEventFilter = TypedEventFilter<PegOutDepositEvent>;

export interface PegOutRefundedEventObject {
  quoteHash: string;
}
export type PegOutRefundedEvent = TypedEvent<
  [string],
  PegOutRefundedEventObject
>;

export type PegOutRefundedEventFilter = TypedEventFilter<PegOutRefundedEvent>;

export interface PegOutUserRefundedEventObject {
  quoteHash: string;
  value: BigNumber;
  userAddress: string;
}
export type PegOutUserRefundedEvent = TypedEvent<
  [string, BigNumber, string],
  PegOutUserRefundedEventObject
>;

export type PegOutUserRefundedEventFilter =
  TypedEventFilter<PegOutUserRefundedEvent>;

export interface PegoutCollateralIncreaseEventObject {
  from: string;
  amount: BigNumber;
}
export type PegoutCollateralIncreaseEvent = TypedEvent<
  [string, BigNumber],
  PegoutCollateralIncreaseEventObject
>;

export type PegoutCollateralIncreaseEventFilter =
  TypedEventFilter<PegoutCollateralIncreaseEvent>;

export interface PenalizedEventObject {
  liquidityProvider: string;
  penalty: BigNumber;
  quoteHash: string;
}
export type PenalizedEvent = TypedEvent<
  [string, BigNumber, string],
  PenalizedEventObject
>;

export type PenalizedEventFilter = TypedEventFilter<PenalizedEvent>;

export interface ProviderUpdateEventObject {
  providerAddress: string;
  name: string;
  url: string;
}
export type ProviderUpdateEvent = TypedEvent<
  [string, string, string],
  ProviderUpdateEventObject
>;

export type ProviderUpdateEventFilter = TypedEventFilter<ProviderUpdateEvent>;

export interface RefundEventObject {
  dest: string;
  amount: BigNumber;
  success: boolean;
  quoteHash: string;
}
export type RefundEvent = TypedEvent<
  [string, BigNumber, boolean, string],
  RefundEventObject
>;

export type RefundEventFilter = TypedEventFilter<RefundEvent>;

export interface RegisterEventObject {
  id: BigNumber;
  from: string;
  amount: BigNumber;
}
export type RegisterEvent = TypedEvent<
  [BigNumber, string, BigNumber],
  RegisterEventObject
>;

export type RegisterEventFilter = TypedEventFilter<RegisterEvent>;

export interface ResignedEventObject {
  from: string;
}
export type ResignedEvent = TypedEvent<[string], ResignedEventObject>;

export type ResignedEventFilter = TypedEventFilter<ResignedEvent>;

export interface WithdrawCollateralEventObject {
  from: string;
  amount: BigNumber;
}
export type WithdrawCollateralEvent = TypedEvent<
  [string, BigNumber],
  WithdrawCollateralEventObject
>;

export type WithdrawCollateralEventFilter =
  TypedEventFilter<WithdrawCollateralEvent>;

export interface WithdrawalEventObject {
  from: string;
  amount: BigNumber;
}
export type WithdrawalEvent = TypedEvent<
  [string, BigNumber],
  WithdrawalEventObject
>;

export type WithdrawalEventFilter = TypedEventFilter<WithdrawalEvent>;

export interface Lbc extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LbcInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    BRIDGE_GENERIC_ERROR(overrides?: CallOverrides): Promise<[number]>;

    BRIDGE_REFUNDED_LP_ERROR_CODE(overrides?: CallOverrides): Promise<[number]>;

    BRIDGE_REFUNDED_USER_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<[number]>;

    BRIDGE_UNPROCESSABLE_TX_ALREADY_PROCESSED_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<[number]>;

    BRIDGE_UNPROCESSABLE_TX_INVALID_SENDER_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<[number]>;

    BRIDGE_UNPROCESSABLE_TX_NOT_CONTRACT_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<[number]>;

    BRIDGE_UNPROCESSABLE_TX_UTXO_AMOUNT_SENT_BELOW_MINIMUM_ERROR(
      overrides?: CallOverrides
    ): Promise<[number]>;

    BRIDGE_UNPROCESSABLE_TX_VALIDATIONS_ERROR(
      overrides?: CallOverrides
    ): Promise<[number]>;

    BRIDGE_UNPROCESSABLE_TX_VALUE_ZERO_ERROR(
      overrides?: CallOverrides
    ): Promise<[number]>;

    CALL_DONE_CODE(overrides?: CallOverrides): Promise<[number]>;

    MAX_CALL_GAS_COST(overrides?: CallOverrides): Promise<[number]>;

    MAX_REFUND_GAS_LIMIT(overrides?: CallOverrides): Promise<[number]>;

    PAY_TO_ADDRESS_OUTPUT(overrides?: CallOverrides): Promise<[BigNumber]>;

    PROCESSED_QUOTE_CODE(overrides?: CallOverrides): Promise<[number]>;

    QUOTE_HASH_OUTPUT(overrides?: CallOverrides): Promise<[BigNumber]>;

    UNPROCESSED_QUOTE_CODE(overrides?: CallOverrides): Promise<[number]>;

    bridge(overrides?: CallOverrides): Promise<[string]>;

    daoFeeCollectorAddress(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    productFeePercentage(overrides?: CallOverrides): Promise<[BigNumber]>;

    providerId(overrides?: CallOverrides): Promise<[BigNumber]>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setProviderStatus(
      _providerId: PromiseOrValue<BigNumberish>,
      status: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getProviderIds(overrides?: CallOverrides): Promise<[BigNumber]>;

    getBridgeAddress(overrides?: CallOverrides): Promise<[string]>;

    getMinCollateral(overrides?: CallOverrides): Promise<[BigNumber]>;

    getMinPegIn(overrides?: CallOverrides): Promise<[BigNumber]>;

    getRewardPercentage(overrides?: CallOverrides): Promise<[BigNumber]>;

    getResignDelayBlocks(overrides?: CallOverrides): Promise<[BigNumber]>;

    getDustThreshold(overrides?: CallOverrides): Promise<[BigNumber]>;

    isPegOutQuoteCompleted(
      quoteHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isOperational(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isOperationalForPegout(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    register(
      _name: PromiseOrValue<string>,
      _apiBaseUrl: PromiseOrValue<string>,
      _status: PromiseOrValue<boolean>,
      _providerType: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getProviders(
      overrides?: CallOverrides
    ): Promise<[LiquidityBridgeContractV2.LiquidityProviderStructOutput[]]>;

    getProvider(
      providerAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[LiquidityBridgeContractV2.LiquidityProviderStructOutput]>;

    addCollateral(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addPegoutCollateral(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deposit(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawCollateral(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    resign(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getCollateral(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getPegoutCollateral(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getBalance(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    callForUser(
      quote: QuotesV2.PeginQuoteStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerPegIn(
      quote: QuotesV2.PeginQuoteStruct,
      signature: PromiseOrValue<BytesLike>,
      btcRawTransaction: PromiseOrValue<BytesLike>,
      partialMerkleTree: PromiseOrValue<BytesLike>,
      height: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositPegout(
      quote: QuotesV2.PegOutQuoteStruct,
      signature: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    refundUserPegOut(
      quoteHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    refundPegOut(
      quoteHash: PromiseOrValue<BytesLike>,
      btcTx: PromiseOrValue<BytesLike>,
      btcBlockHeaderHash: PromiseOrValue<BytesLike>,
      partialMerkleTree: PromiseOrValue<BigNumberish>,
      merkleBranchHashes: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    validatePeginDepositAddress(
      quote: QuotesV2.PeginQuoteStruct,
      depositAddress: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    hashQuote(
      quote: QuotesV2.PeginQuoteStruct,
      overrides?: CallOverrides
    ): Promise<[string]>;

    hashPegoutQuote(
      quote: QuotesV2.PegOutQuoteStruct,
      overrides?: CallOverrides
    ): Promise<[string]>;

    updateProvider(
      _name: PromiseOrValue<string>,
      _url: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  BRIDGE_GENERIC_ERROR(overrides?: CallOverrides): Promise<number>;

  BRIDGE_REFUNDED_LP_ERROR_CODE(overrides?: CallOverrides): Promise<number>;

  BRIDGE_REFUNDED_USER_ERROR_CODE(overrides?: CallOverrides): Promise<number>;

  BRIDGE_UNPROCESSABLE_TX_ALREADY_PROCESSED_ERROR_CODE(
    overrides?: CallOverrides
  ): Promise<number>;

  BRIDGE_UNPROCESSABLE_TX_INVALID_SENDER_ERROR_CODE(
    overrides?: CallOverrides
  ): Promise<number>;

  BRIDGE_UNPROCESSABLE_TX_NOT_CONTRACT_ERROR_CODE(
    overrides?: CallOverrides
  ): Promise<number>;

  BRIDGE_UNPROCESSABLE_TX_UTXO_AMOUNT_SENT_BELOW_MINIMUM_ERROR(
    overrides?: CallOverrides
  ): Promise<number>;

  BRIDGE_UNPROCESSABLE_TX_VALIDATIONS_ERROR(
    overrides?: CallOverrides
  ): Promise<number>;

  BRIDGE_UNPROCESSABLE_TX_VALUE_ZERO_ERROR(
    overrides?: CallOverrides
  ): Promise<number>;

  CALL_DONE_CODE(overrides?: CallOverrides): Promise<number>;

  MAX_CALL_GAS_COST(overrides?: CallOverrides): Promise<number>;

  MAX_REFUND_GAS_LIMIT(overrides?: CallOverrides): Promise<number>;

  PAY_TO_ADDRESS_OUTPUT(overrides?: CallOverrides): Promise<BigNumber>;

  PROCESSED_QUOTE_CODE(overrides?: CallOverrides): Promise<number>;

  QUOTE_HASH_OUTPUT(overrides?: CallOverrides): Promise<BigNumber>;

  UNPROCESSED_QUOTE_CODE(overrides?: CallOverrides): Promise<number>;

  bridge(overrides?: CallOverrides): Promise<string>;

  daoFeeCollectorAddress(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  productFeePercentage(overrides?: CallOverrides): Promise<BigNumber>;

  providerId(overrides?: CallOverrides): Promise<BigNumber>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setProviderStatus(
    _providerId: PromiseOrValue<BigNumberish>,
    status: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getProviderIds(overrides?: CallOverrides): Promise<BigNumber>;

  getBridgeAddress(overrides?: CallOverrides): Promise<string>;

  getMinCollateral(overrides?: CallOverrides): Promise<BigNumber>;

  getMinPegIn(overrides?: CallOverrides): Promise<BigNumber>;

  getRewardPercentage(overrides?: CallOverrides): Promise<BigNumber>;

  getResignDelayBlocks(overrides?: CallOverrides): Promise<BigNumber>;

  getDustThreshold(overrides?: CallOverrides): Promise<BigNumber>;

  isPegOutQuoteCompleted(
    quoteHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isOperational(
    addr: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isOperationalForPegout(
    addr: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  register(
    _name: PromiseOrValue<string>,
    _apiBaseUrl: PromiseOrValue<string>,
    _status: PromiseOrValue<boolean>,
    _providerType: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getProviders(
    overrides?: CallOverrides
  ): Promise<LiquidityBridgeContractV2.LiquidityProviderStructOutput[]>;

  getProvider(
    providerAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<LiquidityBridgeContractV2.LiquidityProviderStructOutput>;

  addCollateral(
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addPegoutCollateral(
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deposit(
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawCollateral(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  resign(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getCollateral(
    addr: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getPegoutCollateral(
    addr: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getBalance(
    addr: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callForUser(
    quote: QuotesV2.PeginQuoteStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerPegIn(
    quote: QuotesV2.PeginQuoteStruct,
    signature: PromiseOrValue<BytesLike>,
    btcRawTransaction: PromiseOrValue<BytesLike>,
    partialMerkleTree: PromiseOrValue<BytesLike>,
    height: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositPegout(
    quote: QuotesV2.PegOutQuoteStruct,
    signature: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  refundUserPegOut(
    quoteHash: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  refundPegOut(
    quoteHash: PromiseOrValue<BytesLike>,
    btcTx: PromiseOrValue<BytesLike>,
    btcBlockHeaderHash: PromiseOrValue<BytesLike>,
    partialMerkleTree: PromiseOrValue<BigNumberish>,
    merkleBranchHashes: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  validatePeginDepositAddress(
    quote: QuotesV2.PeginQuoteStruct,
    depositAddress: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  hashQuote(
    quote: QuotesV2.PeginQuoteStruct,
    overrides?: CallOverrides
  ): Promise<string>;

  hashPegoutQuote(
    quote: QuotesV2.PegOutQuoteStruct,
    overrides?: CallOverrides
  ): Promise<string>;

  updateProvider(
    _name: PromiseOrValue<string>,
    _url: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    BRIDGE_GENERIC_ERROR(overrides?: CallOverrides): Promise<number>;

    BRIDGE_REFUNDED_LP_ERROR_CODE(overrides?: CallOverrides): Promise<number>;

    BRIDGE_REFUNDED_USER_ERROR_CODE(overrides?: CallOverrides): Promise<number>;

    BRIDGE_UNPROCESSABLE_TX_ALREADY_PROCESSED_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<number>;

    BRIDGE_UNPROCESSABLE_TX_INVALID_SENDER_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<number>;

    BRIDGE_UNPROCESSABLE_TX_NOT_CONTRACT_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<number>;

    BRIDGE_UNPROCESSABLE_TX_UTXO_AMOUNT_SENT_BELOW_MINIMUM_ERROR(
      overrides?: CallOverrides
    ): Promise<number>;

    BRIDGE_UNPROCESSABLE_TX_VALIDATIONS_ERROR(
      overrides?: CallOverrides
    ): Promise<number>;

    BRIDGE_UNPROCESSABLE_TX_VALUE_ZERO_ERROR(
      overrides?: CallOverrides
    ): Promise<number>;

    CALL_DONE_CODE(overrides?: CallOverrides): Promise<number>;

    MAX_CALL_GAS_COST(overrides?: CallOverrides): Promise<number>;

    MAX_REFUND_GAS_LIMIT(overrides?: CallOverrides): Promise<number>;

    PAY_TO_ADDRESS_OUTPUT(overrides?: CallOverrides): Promise<BigNumber>;

    PROCESSED_QUOTE_CODE(overrides?: CallOverrides): Promise<number>;

    QUOTE_HASH_OUTPUT(overrides?: CallOverrides): Promise<BigNumber>;

    UNPROCESSED_QUOTE_CODE(overrides?: CallOverrides): Promise<number>;

    bridge(overrides?: CallOverrides): Promise<string>;

    daoFeeCollectorAddress(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    productFeePercentage(overrides?: CallOverrides): Promise<BigNumber>;

    providerId(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setProviderStatus(
      _providerId: PromiseOrValue<BigNumberish>,
      status: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    getProviderIds(overrides?: CallOverrides): Promise<BigNumber>;

    getBridgeAddress(overrides?: CallOverrides): Promise<string>;

    getMinCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    getMinPegIn(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardPercentage(overrides?: CallOverrides): Promise<BigNumber>;

    getResignDelayBlocks(overrides?: CallOverrides): Promise<BigNumber>;

    getDustThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    isPegOutQuoteCompleted(
      quoteHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isOperational(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isOperationalForPegout(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    register(
      _name: PromiseOrValue<string>,
      _apiBaseUrl: PromiseOrValue<string>,
      _status: PromiseOrValue<boolean>,
      _providerType: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProviders(
      overrides?: CallOverrides
    ): Promise<LiquidityBridgeContractV2.LiquidityProviderStructOutput[]>;

    getProvider(
      providerAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<LiquidityBridgeContractV2.LiquidityProviderStructOutput>;

    addCollateral(overrides?: CallOverrides): Promise<void>;

    addPegoutCollateral(overrides?: CallOverrides): Promise<void>;

    deposit(overrides?: CallOverrides): Promise<void>;

    withdraw(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawCollateral(overrides?: CallOverrides): Promise<void>;

    resign(overrides?: CallOverrides): Promise<void>;

    getCollateral(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPegoutCollateral(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBalance(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    callForUser(
      quote: QuotesV2.PeginQuoteStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    registerPegIn(
      quote: QuotesV2.PeginQuoteStruct,
      signature: PromiseOrValue<BytesLike>,
      btcRawTransaction: PromiseOrValue<BytesLike>,
      partialMerkleTree: PromiseOrValue<BytesLike>,
      height: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    depositPegout(
      quote: QuotesV2.PegOutQuoteStruct,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    refundUserPegOut(
      quoteHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    refundPegOut(
      quoteHash: PromiseOrValue<BytesLike>,
      btcTx: PromiseOrValue<BytesLike>,
      btcBlockHeaderHash: PromiseOrValue<BytesLike>,
      partialMerkleTree: PromiseOrValue<BigNumberish>,
      merkleBranchHashes: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    validatePeginDepositAddress(
      quote: QuotesV2.PeginQuoteStruct,
      depositAddress: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    hashQuote(
      quote: QuotesV2.PeginQuoteStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    hashPegoutQuote(
      quote: QuotesV2.PegOutQuoteStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    updateProvider(
      _name: PromiseOrValue<string>,
      _url: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "BalanceDecrease(address,uint256)"(
      dest?: null,
      amount?: null
    ): BalanceDecreaseEventFilter;
    BalanceDecrease(dest?: null, amount?: null): BalanceDecreaseEventFilter;

    "BalanceIncrease(address,uint256)"(
      dest?: null,
      amount?: null
    ): BalanceIncreaseEventFilter;
    BalanceIncrease(dest?: null, amount?: null): BalanceIncreaseEventFilter;

    "BridgeCapExceeded(bytes32,int256)"(
      quoteHash?: null,
      errorCode?: null
    ): BridgeCapExceededEventFilter;
    BridgeCapExceeded(
      quoteHash?: null,
      errorCode?: null
    ): BridgeCapExceededEventFilter;

    "CallForUser(address,address,uint256,uint256,bytes,bool,bytes32)"(
      from?: PromiseOrValue<string> | null,
      dest?: PromiseOrValue<string> | null,
      gasLimit?: null,
      value?: null,
      data?: null,
      success?: null,
      quoteHash?: null
    ): CallForUserEventFilter;
    CallForUser(
      from?: PromiseOrValue<string> | null,
      dest?: PromiseOrValue<string> | null,
      gasLimit?: null,
      value?: null,
      data?: null,
      success?: null,
      quoteHash?: null
    ): CallForUserEventFilter;

    "CollateralIncrease(address,uint256)"(
      from?: null,
      amount?: null
    ): CollateralIncreaseEventFilter;
    CollateralIncrease(
      from?: null,
      amount?: null
    ): CollateralIncreaseEventFilter;

    "DaoFeeSent(bytes32,uint256)"(
      quoteHash?: PromiseOrValue<BytesLike> | null,
      amount?: null
    ): DaoFeeSentEventFilter;
    DaoFeeSent(
      quoteHash?: PromiseOrValue<BytesLike> | null,
      amount?: null
    ): DaoFeeSentEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "PegInRegistered(bytes32,int256)"(
      quoteHash?: PromiseOrValue<BytesLike> | null,
      transferredAmount?: null
    ): PegInRegisteredEventFilter;
    PegInRegistered(
      quoteHash?: PromiseOrValue<BytesLike> | null,
      transferredAmount?: null
    ): PegInRegisteredEventFilter;

    "PegOutDeposit(bytes32,address,uint256,uint256)"(
      quoteHash?: PromiseOrValue<BytesLike> | null,
      sender?: PromiseOrValue<string> | null,
      amount?: null,
      timestamp?: null
    ): PegOutDepositEventFilter;
    PegOutDeposit(
      quoteHash?: PromiseOrValue<BytesLike> | null,
      sender?: PromiseOrValue<string> | null,
      amount?: null,
      timestamp?: null
    ): PegOutDepositEventFilter;

    "PegOutRefunded(bytes32)"(
      quoteHash?: PromiseOrValue<BytesLike> | null
    ): PegOutRefundedEventFilter;
    PegOutRefunded(
      quoteHash?: PromiseOrValue<BytesLike> | null
    ): PegOutRefundedEventFilter;

    "PegOutUserRefunded(bytes32,uint256,address)"(
      quoteHash?: PromiseOrValue<BytesLike> | null,
      value?: null,
      userAddress?: null
    ): PegOutUserRefundedEventFilter;
    PegOutUserRefunded(
      quoteHash?: PromiseOrValue<BytesLike> | null,
      value?: null,
      userAddress?: null
    ): PegOutUserRefundedEventFilter;

    "PegoutCollateralIncrease(address,uint256)"(
      from?: null,
      amount?: null
    ): PegoutCollateralIncreaseEventFilter;
    PegoutCollateralIncrease(
      from?: null,
      amount?: null
    ): PegoutCollateralIncreaseEventFilter;

    "Penalized(address,uint256,bytes32)"(
      liquidityProvider?: null,
      penalty?: null,
      quoteHash?: null
    ): PenalizedEventFilter;
    Penalized(
      liquidityProvider?: null,
      penalty?: null,
      quoteHash?: null
    ): PenalizedEventFilter;

    "ProviderUpdate(address,string,string)"(
      providerAddress?: PromiseOrValue<string> | null,
      name?: null,
      url?: null
    ): ProviderUpdateEventFilter;
    ProviderUpdate(
      providerAddress?: PromiseOrValue<string> | null,
      name?: null,
      url?: null
    ): ProviderUpdateEventFilter;

    "Refund(address,uint256,bool,bytes32)"(
      dest?: null,
      amount?: null,
      success?: null,
      quoteHash?: null
    ): RefundEventFilter;
    Refund(
      dest?: null,
      amount?: null,
      success?: null,
      quoteHash?: null
    ): RefundEventFilter;

    "Register(uint256,address,uint256)"(
      id?: null,
      from?: PromiseOrValue<string> | null,
      amount?: null
    ): RegisterEventFilter;
    Register(
      id?: null,
      from?: PromiseOrValue<string> | null,
      amount?: null
    ): RegisterEventFilter;

    "Resigned(address)"(from?: null): ResignedEventFilter;
    Resigned(from?: null): ResignedEventFilter;

    "WithdrawCollateral(address,uint256)"(
      from?: null,
      amount?: null
    ): WithdrawCollateralEventFilter;
    WithdrawCollateral(
      from?: null,
      amount?: null
    ): WithdrawCollateralEventFilter;

    "Withdrawal(address,uint256)"(
      from?: null,
      amount?: null
    ): WithdrawalEventFilter;
    Withdrawal(from?: null, amount?: null): WithdrawalEventFilter;
  };

  estimateGas: {
    BRIDGE_GENERIC_ERROR(overrides?: CallOverrides): Promise<BigNumber>;

    BRIDGE_REFUNDED_LP_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    BRIDGE_REFUNDED_USER_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    BRIDGE_UNPROCESSABLE_TX_ALREADY_PROCESSED_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    BRIDGE_UNPROCESSABLE_TX_INVALID_SENDER_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    BRIDGE_UNPROCESSABLE_TX_NOT_CONTRACT_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    BRIDGE_UNPROCESSABLE_TX_UTXO_AMOUNT_SENT_BELOW_MINIMUM_ERROR(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    BRIDGE_UNPROCESSABLE_TX_VALIDATIONS_ERROR(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    BRIDGE_UNPROCESSABLE_TX_VALUE_ZERO_ERROR(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    CALL_DONE_CODE(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_CALL_GAS_COST(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_REFUND_GAS_LIMIT(overrides?: CallOverrides): Promise<BigNumber>;

    PAY_TO_ADDRESS_OUTPUT(overrides?: CallOverrides): Promise<BigNumber>;

    PROCESSED_QUOTE_CODE(overrides?: CallOverrides): Promise<BigNumber>;

    QUOTE_HASH_OUTPUT(overrides?: CallOverrides): Promise<BigNumber>;

    UNPROCESSED_QUOTE_CODE(overrides?: CallOverrides): Promise<BigNumber>;

    bridge(overrides?: CallOverrides): Promise<BigNumber>;

    daoFeeCollectorAddress(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    productFeePercentage(overrides?: CallOverrides): Promise<BigNumber>;

    providerId(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setProviderStatus(
      _providerId: PromiseOrValue<BigNumberish>,
      status: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getProviderIds(overrides?: CallOverrides): Promise<BigNumber>;

    getBridgeAddress(overrides?: CallOverrides): Promise<BigNumber>;

    getMinCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    getMinPegIn(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardPercentage(overrides?: CallOverrides): Promise<BigNumber>;

    getResignDelayBlocks(overrides?: CallOverrides): Promise<BigNumber>;

    getDustThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    isPegOutQuoteCompleted(
      quoteHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOperational(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOperationalForPegout(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    register(
      _name: PromiseOrValue<string>,
      _apiBaseUrl: PromiseOrValue<string>,
      _status: PromiseOrValue<boolean>,
      _providerType: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getProviders(overrides?: CallOverrides): Promise<BigNumber>;

    getProvider(
      providerAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addCollateral(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addPegoutCollateral(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deposit(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawCollateral(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    resign(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getCollateral(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPegoutCollateral(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBalance(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    callForUser(
      quote: QuotesV2.PeginQuoteStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerPegIn(
      quote: QuotesV2.PeginQuoteStruct,
      signature: PromiseOrValue<BytesLike>,
      btcRawTransaction: PromiseOrValue<BytesLike>,
      partialMerkleTree: PromiseOrValue<BytesLike>,
      height: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositPegout(
      quote: QuotesV2.PegOutQuoteStruct,
      signature: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    refundUserPegOut(
      quoteHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    refundPegOut(
      quoteHash: PromiseOrValue<BytesLike>,
      btcTx: PromiseOrValue<BytesLike>,
      btcBlockHeaderHash: PromiseOrValue<BytesLike>,
      partialMerkleTree: PromiseOrValue<BigNumberish>,
      merkleBranchHashes: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    validatePeginDepositAddress(
      quote: QuotesV2.PeginQuoteStruct,
      depositAddress: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashQuote(
      quote: QuotesV2.PeginQuoteStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashPegoutQuote(
      quote: QuotesV2.PegOutQuoteStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateProvider(
      _name: PromiseOrValue<string>,
      _url: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    BRIDGE_GENERIC_ERROR(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BRIDGE_REFUNDED_LP_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BRIDGE_REFUNDED_USER_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BRIDGE_UNPROCESSABLE_TX_ALREADY_PROCESSED_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BRIDGE_UNPROCESSABLE_TX_INVALID_SENDER_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BRIDGE_UNPROCESSABLE_TX_NOT_CONTRACT_ERROR_CODE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BRIDGE_UNPROCESSABLE_TX_UTXO_AMOUNT_SENT_BELOW_MINIMUM_ERROR(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BRIDGE_UNPROCESSABLE_TX_VALIDATIONS_ERROR(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BRIDGE_UNPROCESSABLE_TX_VALUE_ZERO_ERROR(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    CALL_DONE_CODE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_CALL_GAS_COST(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_REFUND_GAS_LIMIT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    PAY_TO_ADDRESS_OUTPUT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    PROCESSED_QUOTE_CODE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    QUOTE_HASH_OUTPUT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    UNPROCESSED_QUOTE_CODE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    bridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    daoFeeCollectorAddress(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    productFeePercentage(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    providerId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setProviderStatus(
      _providerId: PromiseOrValue<BigNumberish>,
      status: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getProviderIds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBridgeAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMinCollateral(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMinPegIn(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRewardPercentage(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getResignDelayBlocks(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDustThreshold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isPegOutQuoteCompleted(
      quoteHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isOperational(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isOperationalForPegout(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    register(
      _name: PromiseOrValue<string>,
      _apiBaseUrl: PromiseOrValue<string>,
      _status: PromiseOrValue<boolean>,
      _providerType: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getProviders(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getProvider(
      providerAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addCollateral(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addPegoutCollateral(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deposit(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawCollateral(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    resign(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getCollateral(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPegoutCollateral(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBalance(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    callForUser(
      quote: QuotesV2.PeginQuoteStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerPegIn(
      quote: QuotesV2.PeginQuoteStruct,
      signature: PromiseOrValue<BytesLike>,
      btcRawTransaction: PromiseOrValue<BytesLike>,
      partialMerkleTree: PromiseOrValue<BytesLike>,
      height: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositPegout(
      quote: QuotesV2.PegOutQuoteStruct,
      signature: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    refundUserPegOut(
      quoteHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    refundPegOut(
      quoteHash: PromiseOrValue<BytesLike>,
      btcTx: PromiseOrValue<BytesLike>,
      btcBlockHeaderHash: PromiseOrValue<BytesLike>,
      partialMerkleTree: PromiseOrValue<BigNumberish>,
      merkleBranchHashes: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    validatePeginDepositAddress(
      quote: QuotesV2.PeginQuoteStruct,
      depositAddress: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashQuote(
      quote: QuotesV2.PeginQuoteStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashPegoutQuote(
      quote: QuotesV2.PegOutQuoteStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    updateProvider(
      _name: PromiseOrValue<string>,
      _url: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
